\documentclass[ignorenonframetext,]{beamer}
\setbeamertemplate{caption}[numbered]
\setbeamertemplate{caption label separator}{: }
\setbeamercolor{caption name}{fg=normal text.fg}
\beamertemplatenavigationsymbolsempty
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
\usefonttheme{structurebold}
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\newif\ifbibliography
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{{#1}}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{{#1}}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{{#1}}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{{#1}}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{{#1}}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{{#1}}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{{#1}}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{{#1}}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{{#1}}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{{#1}}}
\newcommand{\ImportTok}[1]{{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{{#1}}}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{{#1}}}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{{#1}}}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{{#1}}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{{#1}}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{{#1}}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{{#1}}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{{#1}}}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{{#1}}}}
\newcommand{\BuiltInTok}[1]{{#1}}
\newcommand{\ExtensionTok}[1]{{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{{#1}}}
\newcommand{\RegionMarkerTok}[1]{{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{{#1}}}}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{{#1}}}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\NormalTok}[1]{{#1}}
\usepackage{longtable,booktabs}
\usepackage{caption}
% These lines are needed to make table captions work with longtable:
\makeatletter
\def\fnum@table{\tablename~\thetable}
\makeatother

% Prevent slide breaks in the middle of a paragraph:
\widowpenalties 1 10000
\raggedbottom

\AtBeginPart{
  \let\insertpartnumber\relax
  \let\partname\relax
  \frame{\partpage}
}
\AtBeginSection{
  \ifbibliography
  \else
    \let\insertsectionnumber\relax
    \let\sectionname\relax
    \frame{\sectionpage}
  \fi
}
\AtBeginSubsection{
  \let\insertsubsectionnumber\relax
  \let\subsectionname\relax
  \frame{\subsectionpage}
}

\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
\definecolor{links}{HTML}{800080}
\hypersetup{colorlinks,linkcolor=,urlcolor=links}

\title{Web Data Collection with R}
\subtitle{Regular Expressions / RegEx}
\author{Peter Meißner / 2016-02-29 -- 2016-03-04 / ECPR WSMT}
\date{}

\begin{document}
\frame{\titlepage}

\begin{frame}
\tableofcontents[hideallsubsections]
\end{frame}

\section{How Regular Expressions work
\ldots{}}\label{how-regular-expressions-work}

\begin{frame}[fragile]{What is it all about?}

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\tightlist
\item
  Regular Expressions refer to combination of two things

  \begin{itemize}
  \tightlist
  \item
    a \textbf{syntax} that allows to define string patterns

    \begin{itemize}
    \tightlist
    \item
      e.g.: ``\texttt{{[}pP{]}eter}'',
      ``\texttt{\textbackslash{}\textbackslash{}d\{4\}-\textbackslash{}\textbackslash{}d\{1,2\}-\textbackslash{}\textbackslash{}d\{1,2\}}''
    \end{itemize}
  \item
    a set of \textbf{functions} doing string handling

    \begin{itemize}
    \tightlist
    \item
      base R has \texttt{grep()}, \texttt{grepl()},
      \texttt{substring()}, \ldots{} nice because of options ignore.case
      and invert and bcause build in
    \item
      more convenient stringr/stringi functions: \texttt{str\_detect()},
      \texttt{str\_replace()}, \texttt{str\_extract()}, \ldots{}
    \end{itemize}
  \end{itemize}
\end{enumerate}

\end{frame}

\section{Patterns}\label{patterns}

\begin{frame}[fragile]{Patterns}

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\setcounter{enumi}{1}
\item
  \href{http://regexlib.com/CheatSheet.aspx}{Regular Expressions
  providing string patterns}

  \begin{longtable}[c]{@{}ll@{}}
  \toprule
  pattern & description\tabularnewline
  \midrule
  \endhead
  \textbf{\texttt{"Hallo"}} & 1:1\tabularnewline
  \textbf{\texttt{"."}} & any character\tabularnewline
  \textbf{\texttt{"{[}{]}"}} & placeholder for one
  character\tabularnewline
  \textbf{\texttt{"{[}abc{]}"}} & set of characters (e.g.~a,b, and
  c)\tabularnewline
  \textbf{\texttt{"{[}a-z{]}"}} & range of characters (e.g.~a-z, not è,
  ä, \ldots{})\tabularnewline
  \textbf{\texttt{"a*"} / \texttt{"a+"}} & none or more / one or
  more\tabularnewline
  \textbf{\texttt{"a\{2,4\}"}} & two up to four\tabularnewline
  \textbf{\texttt{"ac\textbar{}b"}} & ac or b\tabularnewline
  \textbf{\texttt{"{[}\^{}ab{]}"}} & non of those\tabularnewline
  \textbf{\texttt{"\^{}a"}} & starting with a\tabularnewline
  \textbf{\texttt{"a\$"}} & ending with a\tabularnewline
  \bottomrule
  \end{longtable}
\end{enumerate}

\end{frame}

\begin{frame}[fragile]{Special Characters}

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\setcounter{enumi}{2}
\item
  \href{http://regexlib.com/CheatSheet.aspx}{Expressing Patterns}

  \begin{longtable}[c]{@{}ll@{}}
  \toprule
  pattern & description\tabularnewline
  \midrule
  \endhead
  \textbf{\texttt{"\textbackslash{}n"}} & newline\tabularnewline
  \textbf{\texttt{"\textbackslash{}r"}} & carriage return\tabularnewline
  \textbf{\texttt{"\textbackslash{}t"}} & tab\tabularnewline
  \textbf{\texttt{"\textbackslash{}b"}} & word boundary (between
  \texttt{"\textbackslash{}\textbackslash{}w"} and
  \texttt{"\textbackslash{}\textbackslash{}W"})\tabularnewline
  \textbf{\texttt{"\textbackslash{}122"}} & {[}matches ASCII character
  number 82 (octal)\tabularnewline
  \textbf{\texttt{"\textbackslash{}x52"}} & matches ASCII character
  number 82 (hexadecimal)\tabularnewline
  \textbf{\texttt{"\textbackslash{}u0052"}} & matches Unicode character
  number 82 (hexadecimal)\tabularnewline
  \bottomrule
  \end{longtable}
\end{enumerate}

\end{frame}

\begin{frame}[fragile]{Character Classes}

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\setcounter{enumi}{2}
\tightlist
\item
  \href{http://regexlib.com/CheatSheet.aspx}{Expressing Character
  Classes}
\end{enumerate}

\begin{longtable}[c]{@{}ll@{}}
\toprule
pattern & description\tabularnewline
\midrule
\endhead
\textbf{\texttt{"\textbackslash{}\textbackslash{}d"} /
\texttt{"\textbackslash{}\textbackslash{}D"}} & digit / no
digit\tabularnewline
\textbf{\texttt{"\textbackslash{}\textbackslash{}w"} /
\texttt{"\textbackslash{}\textbackslash{}W"}} & word char. / no word
char\tabularnewline
\textbf{\texttt{"\textbackslash{}\textbackslash{}s"} /
\texttt{"\textbackslash{}\textbackslash{}S"}} & white space char. / no
ws char\tabularnewline
\textbf{\texttt{"\textbackslash{}\textbackslash{}p\{Currency\_Symbol\}"}}
& \href{http://www.regular-expressions.info/unicode.html}{unicode groups
and blocks}\tabularnewline
\textbf{\texttt{"{[}{[}:digit:{]}{]}"}} & digit\tabularnewline
\textbf{\texttt{"{[}{[}:alpha:{]}{]}"}} & characters (also
è)\tabularnewline
\textbf{\texttt{"{[}{[}:alphanum:{]}{]}"}} & word char.\tabularnewline
\textbf{\texttt{"{[}\^{}{[}:alphanum:{]}{]}"}} & white space
char.\tabularnewline
\bottomrule
\end{longtable}

\end{frame}

\begin{frame}[fragile]{Syntax Characters}

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\setcounter{enumi}{3}
\tightlist
\item
  some characters have special meaning and cannot be used literally
\end{enumerate}

\begin{itemize}
\item
  ~ . \$ \^{} \{ {[} ( \textbar{} ) {]} \} * + ?

  \begin{longtable}[c]{@{}lll@{}}
  \toprule
  character & description & matching\tabularnewline
  \midrule
  \endhead
  \textbf{\texttt{"\textbackslash{}"}} & escapes
  \texttt{"\textbackslash{}"}, extra chars &
  \texttt{grep("\textbackslash{}\textbackslash{}\textbackslash{}\textbackslash{}","\textbackslash{}\textbackslash{}")}\tabularnewline
  \textbf{\texttt{"\{"}} & numeral classifier &
  \texttt{grep("\textbackslash{}\textbackslash{}\{","\{")}\tabularnewline
  \ldots{} & \ldots{} & \ldots{}\tabularnewline
  \bottomrule
  \end{longtable}
\end{itemize}

\end{frame}

\section{Functions}\label{functions}

\begin{frame}[fragile]{functions for string detection}

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\setcounter{enumi}{4}
\item
  base functions for string detection / manipulation

  \begin{longtable}[c]{@{}ll@{}}
  \toprule
  name & description\tabularnewline
  \midrule
  \endhead
  \texttt{grep()} & searches for pat. and returns numeric
  index/content\tabularnewline
  \texttt{grepl()} & searches for pat. and returns logical
  index\tabularnewline
  \texttt{gregexpr()} & gives back each position of match\tabularnewline
  \texttt{nchar()} & length of string\tabularnewline
  \texttt{substr()} & extracts sequence of characters\tabularnewline
  \texttt{sub()} & replace one pat. match in string with other
  string\tabularnewline
  \texttt{gsub()} & replace all pat. matches in string with other
  string\tabularnewline
  \texttt{paste()} & concatonates vector elements into one
  string\tabularnewline
  \texttt{paste0()} & concatonates vector elements into one
  string\tabularnewline
  \texttt{-} & duplicates string\tabularnewline
  \texttt{-} & removes leading /trailing whitespace\tabularnewline
  \texttt{-} & adds whitespace to left, right, or both\tabularnewline
  \texttt{-} & returns matrix of strings x matches + 1\tabularnewline
  \texttt{cat()} & prints text to screen\tabularnewline
  \bottomrule
  \end{longtable}
\end{enumerate}

\end{frame}

\begin{frame}[fragile]{functions for string detection}

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\setcounter{enumi}{5}
\item
  stringr/stringi functions for string detection / manipulation

  \begin{longtable}[c]{@{}ll@{}}
  \toprule
  name & description\tabularnewline
  \midrule
  \endhead
  \texttt{-} & searches for pat. and ret. numeric
  index/cont.\tabularnewline
  \texttt{str\_detect()} & searches for pat. and returns logical
  index\tabularnewline
  \texttt{str\_locate()} & gives back each position of
  match\tabularnewline
  \texttt{str\_length()} & length of str.\tabularnewline
  \texttt{str\_sub()} & extracts sequence of characters\tabularnewline
  \texttt{str\_replace} & repl. one pat. match in str. with other
  str.\tabularnewline
  \texttt{str\_replace\_all()} & repl. all pat. matches in str. with
  other str.\tabularnewline
  \texttt{-} & concatonates vector elements into one str.\tabularnewline
  \texttt{str\_c()} & concatonates vector elements into one
  str.\tabularnewline
  \texttt{str\_dup} & duplicates string\tabularnewline
  \texttt{str\_trim} & removes leading /trailing
  whitespace\tabularnewline
  \texttt{str\_pad} & adds whitespace to left, right, or
  both\tabularnewline
  \texttt{str\_match} & returns matrix of strings x matches +
  1\tabularnewline
  \texttt{cat()} & prints text to screen\tabularnewline
  \bottomrule
  \end{longtable}
\end{enumerate}

\end{frame}

\section{Character Encodings}\label{character-encodings}

\begin{frame}{Character Encodings}

Character Encodings are \ldots{}

\begin{itemize}
\tightlist
\item
  are like family \ldots{}
\item
  \ldots{} some of them you do not like but cannot avoid \ldots{}
\item
  \ldots{} something we will struggle with but have cope anyways
\end{itemize}

The best thing is \ldots{}

\begin{itemize}
\tightlist
\item
  R has them all
\end{itemize}

The worst thing is \ldots{}

\begin{itemize}
\tightlist
\item
  R has them all
\end{itemize}

\end{frame}

\begin{frame}{Character Encodings}

\begin{itemize}
\tightlist
\item
  computers store everything as 0s and 1s (bits)
\item
  in cs there are differing layers of abstraction
\item
  one bit of information is called bit
\item
  bits are quite uninformative as they only ave two states
\item
  so they are are grouped into bytes (8 bits)
\item
  one byte can have 256 different values (2\^{}8)
\item
  so it can store numbers 0 to 255 or 1 to 256 or \ldots{} -127 to 128
\item
  or it can map to characters e.g.~ASCII
  (abcABC.:-\_,;\#'+*\textasciitilde{}\textbar{}\textless{}\textgreater{}!``§\$\%\&/()=?\}{]}{[}\{\}\^{}°,
  \ldots{}'')
\item
  ASCII is a character set - the set of characters you want to be able
  to store - even 7 Bits would suffice to store it
\end{itemize}

\end{frame}

\begin{frame}{Character Encodings}

\begin{itemize}
\tightlist
\item
  for larger character sets than ASCII (ä ö ü é è \ldots{} ) on needs to
  get clever since one byte does not suffice to map all characters to 0s
  and 1s
\item
  unfortunate people got clever in differing ways

  \begin{enumerate}
  \def\labelenumi{\arabic{enumi})}
  \tightlist
  \item
    using more than one byte to map more characters (`wide' characters,
    UTF-16, USC-2, Windows OSs)
  \item
    using one or more bytes and using the first byte to encode how
    manies are used (`multi-byte characters', UTF-8, Unix based OSs)
  \end{enumerate}
\item
  otherwise we would not have to talk about character sets and character
  encodings
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Character Encodings}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rawToBits}\NormalTok{(}\KeywordTok{as.raw}\NormalTok{(}\DecValTok{62}\NormalTok{:}\DecValTok{66}\NormalTok{)) }\CommentTok{# as bits}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 00 01 01 01 01 01 00 00 01 01 01 01 01 01 00 00 00 00 00 00 00 00 01
## [24] 00 01 00 00 00 00 00 01 00 00 01 00 00 00 00 01 00
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.raw}\NormalTok{(}\DecValTok{62}\NormalTok{:}\DecValTok{66}\NormalTok{) }\CommentTok{# bytes as hexa-decimal}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3e 3f 40 41 42
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.numeric}\NormalTok{(}\KeywordTok{as.raw}\NormalTok{(}\DecValTok{62}\NormalTok{:}\DecValTok{66}\NormalTok{)) }\CommentTok{# as numbers}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 62 63 64 65 66
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rawToChar}\NormalTok{(}\KeywordTok{as.raw}\NormalTok{(}\DecValTok{62}\NormalTok{:}\DecValTok{66}\NormalTok{)) }\CommentTok{# bytes as chararcters}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] ">?@AB"
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{A character set problem}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{text           <-}\StringTok{ }\KeywordTok{rawToChar}\NormalTok{(}\KeywordTok{as.raw}\NormalTok{(}\DecValTok{228}\NormalTok{))}
\KeywordTok{Encoding}\NormalTok{(text) <-}\StringTok{ "UTF-8"} 
\NormalTok{text}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "\xe4"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{Encoding}\NormalTok{(text) <-}\StringTok{ "latin1"} 
\NormalTok{text}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "ä"
\end{verbatim}

Results differ because for latin1 character 228 is know but not for
UTF-8

\end{frame}

\begin{frame}[fragile]{An encoding problem}

Of cause UTF-8 knows how to encode ``ä'' \ldots{}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{text <-}\StringTok{ "ä"}
\KeywordTok{charToRaw}\NormalTok{(text)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] c3 a4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{Encoding}\NormalTok{(text) <-}\StringTok{ "latin1"}
\NormalTok{text}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Ã¤"
\end{verbatim}

\ldots{} but here the results differ because ``UTF-8'' has another
system translating characters to bytes. In latin1 the two bytes are
interpreted as two characters.

\end{frame}

\begin{frame}[fragile]{Which default encoding does your R use}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{Sys.getlocale}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "LC_CTYPE=de_DE.UTF-8;LC_NUMERIC=C;LC_TIME=de_DE.UTF-8;LC_COLLATE=de_DE.UTF-8;LC_MONETARY=de_DE.UTF-8;LC_MESSAGES=de_DE.UTF-8;LC_PAPER=de_DE.UTF-8;LC_NAME=C;LC_ADDRESS=C;LC_TELEPHONE=C;LC_MEASUREMENT=de_DE.UTF-8;LC_IDENTIFICATION=C"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# if yor locale is something other than UTF-8, }
\CommentTok{# switch 'latin1' and 'UTF-8' and you shall be good to go}
\end{Highlighting}
\end{Shaded}

\end{frame}

\begin{frame}[fragile]{Changing interpretation of bytes}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{text <-}\StringTok{ "Små grodorna, små grodorna är lustiga att se."}
\KeywordTok{Encoding}\NormalTok{(text) <-}\StringTok{ "UTF-8"}
\NormalTok{text}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Små grodorna, små grodorna är lustiga att se."
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{Changing interpretation of bytes}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{text <-}\StringTok{ "Små grodorna, små grodorna är lustiga att se."}
\KeywordTok{Encoding}\NormalTok{(text) <-}\StringTok{ "latin1"}
\NormalTok{text}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "SmÃ¥ grodorna, smÃ¥ grodorna Ã¤r lustiga att se."
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{Changing bytes and interpretation}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{text <-}\StringTok{ "Små grodorna, små grodorna är lustiga att se."}
\NormalTok{text <-}\StringTok{ }\KeywordTok{iconv}\NormalTok{(text, }\StringTok{"UTF-8"}\NormalTok{, }\StringTok{"latin1"}\NormalTok{)}
\KeywordTok{Encoding}\NormalTok{(text)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "latin1"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{text}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Små grodorna, små grodorna är lustiga att se."
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{Noe that all sources might have another encoding
than your R default locale!}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{text <-}\StringTok{ "Små grodorna, små grodorna är lustiga att se."}
\NormalTok{text <-}\StringTok{ }\KeywordTok{iconv}\NormalTok{(text, }\StringTok{"UTF-8"}\NormalTok{, }\StringTok{"latin1"}\NormalTok{)}
\KeywordTok{writeLines}\NormalTok{(text, }\StringTok{"text_latin1.txt"}\NormalTok{, }\DataTypeTok{useBytes =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{text <-}\StringTok{ }\KeywordTok{readLines}\NormalTok{(}\StringTok{"text_latin1.txt"}\NormalTok{)}
\KeywordTok{Encoding}\NormalTok{(text)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "unknown"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{text}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Sm\xe5 grodorna, sm\xe5 grodorna \xe4r lustiga att se."
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{Encoding}\NormalTok{(text) <-}\StringTok{ "latin1"}
\NormalTok{text}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Små grodorna, små grodorna är lustiga att se."
\end{verbatim}

\end{frame}

\end{document}
